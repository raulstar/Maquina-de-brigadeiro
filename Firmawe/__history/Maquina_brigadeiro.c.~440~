
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  Maquina de cortar brogadeiros
//
//   build 07/04/2023 by Raul
//  v1.0 REV. 100921
//   programmer CCS 5.015
//   debugger/programmer PICKit 3.10
//   microcontroler PIC 16f877
//   IDE CCS 5.015
//   schematic: Labcenter Proteus 8.9
//       @site:www.autorobotica.sp@gmail.com
//       @email: raulstar3@gmail.com ,
//       www.linkedin.com/in/raulstar/, Instagram: @raulstar3,github.com/raulstar
//    External dependencies:

//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <16F877.h>  // Inclui o arquivo de cabeçalho específico para o microcontrolador PIC16F877.

#FUSES WDT        // No Watch Dog Timer - Desativa o Watchdog Timer.
#FUSES PUT        // Power Up Timer - Ativa o Power-Up Timer.
#FUSES NOBROWNOUT // No brownout reset - Desativa o reset por brownout.
#FUSES NOLVP      // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O - Desativa a programação de baixa tensão e define o pino B3 (PIC16) ou B5 (PIC18) para I/O.

#DEVICE ADC = 8   // Configura a precisão do conversor analógico-digital (ADC) para 8 bits.

#use delay(crystal = 4000000)  // Configura a função de delay para usar um oscilador de cristal de 4 MHz como fonte de clock.

#include <lcd.c>  // Inclui o arquivo "lcd.c" que contém funções para o display LCD.

#use fast_io(A)  // Habilita operações rápidas de I/O para o porto A.

// Macros
#define DELAY 1000  // Define a macro "DELAY" com o valor 1000.
#define LED PIN_B5  // Define a macro "LED" como o pino B5.
#define Limit_superior input(PIN_A1)  // Define a macro "Limit_superior" como a leitura do pino A1.
#define Limit_inferior input(PIN_A2)  // Define a macro "Limit_inferior" como a leitura do pino A2.
#define liga input(PIN_E0)  // Define a macro "liga" como a leitura do pino E0.
#define manual input(PIN_C1)  // Define a macro "manual" como a leitura do pino C1.
#define sobe input(PIN_A4)  // Define a macro "sobe" como a leitura do pino A4.
#define desce input(PIN_A5)  // Define a macro "desce" como a leitura do pino A5.
#define habilita input(PIN_A3)  // Define a macro "habilita" como a leitura do pino A3.
#define conte input(PIN_E1)  // Define a macro "conte" como a leitura do pino E1.
#define menu input(PIN_C0)  // Define a macro "menu" como a leitura do pino C0.
#define inverteMotor output_high(PIN_E2)  // Define a macro "inverteMotor" como a saída em nível alto (HIGH) para o pino E2.
#define desinverteMotor output_low(PIN_E2)  // Define a macro "desinverteMotor" como a saída em nível baixo (LOW) para o pino E2.

// Variaveis
int16 acumulador, frequencia, contador;  // Declaração de variáveis: acumulador, frequencia e contador do tipo int16.

signed int16 error_meas, kp = 30, ki = 0, kd = 30, proportional, integral, derivative, PID;  // Declaração de variáveis: error_meas, kp, ki, kd, proportional, integral, derivative e PID do tipo int16, algumas com valores iniciais.

// constantes
int setpoit = 5, duty = 0, pwm_period = 168;  // Valor do período do PWM em us para 1.515 kHz;

signed int potencia = 0, measure = 50, lastMeasure = 80;  // Declaração de variáveis: potencia, measure e lastMeasure do tipo int, com valores iniciais.

int funcao = 0;  // Declaração de variável: funcao do tipo int, com valor inicial 0.


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funções
int16 frequecimetro(int16 acumulador);
void pid_control();
int leitura(void);
float pwm(signed int potencia);
int media(long frequencia);
void comtroleMotor(int duty, setpoit);
int16 contagem(void);
int16 lerMemoria(void);
void escreveMemoria(int16 variavel);
void modo(int funcao);
void atualizaDisplay(void);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Interrupções
#INT_EXT
void EXT_isr(void)
{
  static int1 borda = 0;  // Variável estática para controle de borda
  frequencia = frequecimetro(acumulador);  // Atualiza a variável frequencia com base no valor do acumulador

  if (!borda)  // Verifica se a borda é igual a 0
  {
    borda = 1;  // Define a borda como 1
    ext_int_edge(H_TO_L);  // Configura a interrupção externa para borda de descida
  }
  else
  {
    borda = 0;  // Define a borda como 0
    ext_int_edge(L_TO_H);  // Configura a interrupção externa para borda de subida
  }
  acumulador = 0;  // Reinicia o acumulador
}

#INT_TIMER0
void TIMER0_isr(void)
{
  if (acumulador > 900)  // Verifica se o valor do acumulador é maior que 900
    frequencia = 0;  // Define a frequência como 0
  acumulador++;  // Incrementa o valor do acumulador
}

void main()
{
  // Configuração
  delay_ms(10);  // Pequeno atraso de 10ms
  lcd_init();  // Inicializa o display LCD
  lcd_gotoxy(1, 1);  // Posiciona o cursor na primeira linha, primeira coluna

  setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1 | RTCC_DIV_4);  // Configura o Timer0 com clock interno, divisor 1:4
  setup_ccp1(CCP_PWM);  // Configura o CCP1 para modo PWM
  setup_timer_2(T2_DIV_BY_1, 124, 1);  // Configura o Timer2 com prescaler 1:1, período de 1ms
  set_pwm1_duty(0);  // Define o duty cycle inicial do PWM como 0

  setup_adc_ports(AN0);  // Configura o pino AN0 como entrada analógica
  setup_adc(ADC_CLOCK_DIV_2);  // Configura o clock do ADC com divisor 2
  enable_interrupts(INT_EXT);  // Habilita a interrupção externa
  ext_int_edge(L_TO_H);  // Configura a interrupção externa para borda de subida
  enable_interrupts(INT_TIMER1);  // Habilita a interrupção do Timer1
  enable_interrupts(INT_TIMER0);  // Habilita a interrupção do Timer0
  enable_interrupts(GLOBAL);  // Habilita as interrupções globais
  setup_wdt(WDT_2304MS);  // Configura o Watchdog Timer com um tempo de estouro de 2304ms

  printf(lcd_putc, "e0\r\n");  // Imprime uma mensagem no display LCD
  delay_ms(50);  // Pequeno atraso de 50ms
  printf(lcd_putc, "\fCorta Brigadeiros\n           v1.0");  // Imprime uma mensagem no display LCD

  contador = lerMemoria();  // Lê o valor do contador da memória

  while (true)
  {
    restart_wdt();  // Reinicia o Watchdog Timer
    setpoit = leitura();  // Lê o valor do setpoint
    if (!setpoit)  // Verifica se o setpoint é igual a 0
      duty = 0, potencia = 0;  // Define o duty cycle e a potência como 0
    pid_control();  // Chama a função de controle PID
    duty = pwm(potencia);  // Calcula o valor do duty cycle do PWM com base na potência
    contador = contagem();  // Realiza a contagem
    if (menu)  // Verifica se o botão de menu está pressionado
      contador = 0;  // Define o contador como 0
    modo(funcao);  // Executa o modo correspondente à função
    comtroleMotor(duty, setpoit);  // Controla o motor com base no duty cycle e no setpoint
    delay_ms(10);  // Pequeno atraso de 10ms
    escreveMemoria(contador);  // Escreve o valor do contador na memória
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
int16 frequecimetro(int16 cont)
{
  frequencia = ((float)10000 / (cont * 5.12)); // Calcula a frequência atual do PWM
  float temp = (float)5 * frequencia;
  frequencia = (int)temp;
  return frequencia;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
void pid_control()
{
  int potenciaMinima = 10;
  measure = frequencia;
  error_meas = setpoit - measure;
  proportional = error_meas * kp;
  integral += error_meas * ki;
  derivative = (lastMeasure - measure) * kd;
  lastMeasure = measure;
  PID = proportional + integral + derivative;
  // potencia = PID + setpoit;
  if (potencia < (potenciaMinima))
    potencia = potenciaMinima;
  if (potencia > (PID + setpoit))
    potencia = potencia - 1;
  if (potencia < (PID + setpoit))
    potencia++;
  if (potencia >= 100)
    potencia = 100;
  if (potencia <= 0)
    potencia = 0;

} // end pid_control
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
int leitura(void)
{
  int value;
  float temp;
  set_adc_channel(0);
  value = read_adc();
  temp = ((float)100 / 255) * value;
  value = (int)temp;
  return value;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
float pwm(signed int potencia)
{
  float temp = ((float)pwm_period / 100) * potencia;
  return temp;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
void comtroleMotor(int duty, setpoit)
{

  static int velocidadeManual = 0, limiteVelocidade = 150;

  if (sobe && !Limit_superior)
  {
    funcao = 1;
    set_pwm1_duty(velocidadeManual);
    inverteMotor;
    if (velocidadeManual < limiteVelocidade)
      velocidadeManual = velocidadeManual + 5;
  }
  else if (desce && !Limit_inferior)
  {
    funcao = 2;
    set_pwm1_duty(velocidadeManual);
    if (velocidadeManual < limiteVelocidade)
      velocidadeManual = velocidadeManual + 5;
  }

  else
  {
    if (liga && habilita && !Limit_inferior)
    {
      if (!setpoit)
        funcao = 0;
      desinverteMotor;
      set_pwm1_duty(duty);
    }
    else
    {
      set_pwm1_duty(0);
      potencia = 0;
      if (funcao == 1)
      {
        delay_ms(300);
        funcao = 0;
        desinverteMotor;
      }
    }
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
int16 contagem(void)
{
  static int flag = 0;
  static int16 contadorTmp;
  if (menu)
    contadorTmp = 0;
  if (conte)
  {
    if (!flag)
      contadorTmp++;
    flag = 1;
  }
  else
    flag = 0;
  return contadorTmp;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
void escreveMemoria(int16 variavel)
{
  int byteBaixo, byteAlto, endereco = 0;

  byteBaixo = variavel & 0xFF;
  byteAlto = variavel >> 8;
  write_eeprom(endereco, byteBaixo);
  write_eeprom(endereco + 1, byteAlto);
  if (menu)
  {
    write_eeprom(endereco, 0);
    write_eeprom(endereco + 1, 0);
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
int16 lerMemoria(void)
{
  int16 memoria;
  int byteBaixo, byteAlto, endereco = 0;

  byteBaixo = read_eeprom(endereco);
  byteAlto = read_eeprom(endereco + 1);
  memoria = byteAlto << 8;
  memoria |= byteBaixo;

  return memoria;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
void modo(int funcao)
{

  switch (funcao)
  {

  case 0:
    lcd_gotoxy(1, 1);                             // Posiciona o cursor na segunda linha, primeira coluna
    printf(lcd_putc, "\fVelocidade %u", setpoit); // Imprime a frequência no display

    lcd_gotoxy(1, 2);                            // Posiciona o cursor na segunda linha, primeira coluna
    printf(lcd_putc, "Contador %lu ", contador); // Imprime a frequência no display
                                                 // printf(lcd_putc, "contador %lu rpm", (contador)); // Imprime a frequência no display
    break;

  case 1:
    printf(lcd_putc, "\fvelocidade %u\n sobe", setpoit);
    break;

  case 2:
    printf(lcd_putc, "\fvelocidade %u\n desce", setpoit);
    break;

  case 3:
    printf(lcd_putc, "\fvelocidade %u\n limite inferior", setpoit);
    break;

  case4:
    printf(lcd_putc, "\fvelocidade %u\n desce", setpoit);
    break;
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
void atualizaDisplay(void)
{
  static int t = 0;
  t++;
  if (t == 6)
  {
    t = 0;
    lcd_gotoxy(1, 1);                                       // Posiciona o cursor na segunda linha, primeira coluna
    printf(lcd_putc, "\fVelocidade %u  %u", setpoit, duty); // Imprime a frequência no display

    lcd_gotoxy(1, 2);                          // Posiciona o cursor na segunda linha, primeira coluna
    printf(lcd_putc, "freq %lu ", frequencia); // Imprime a frequência no display
                                               // printf(lcd_putc, "contador %lu rpm", (contador)); // Imprime a frequência no display
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
